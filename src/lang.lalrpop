use builder::{Builder, NodeResult, Op};

grammar<'b>(builder: &'b Builder);

pub Expr: NodeResult<'input> = {
    <l:Expr> "+" <r:Factor> => builder.add(l?, r?),
    <l:Expr> "-" <r:Factor> => builder.sub(l?, r?),
    "-" <f:Factor> => builder.neg(f?),
    Factor,
};

pub Factor: NodeResult<'input> = {
    <l:Factor> "*" <r:Pow> => builder.mul(l?, r?),
    <l:Factor> "Â·" <r:Pow> => builder.mul(l?, r?),
    <l:Factor> "/" <r:Pow> => builder.div(l?, r?),
    <l:Factor> <r:Pow> => builder.mul(l?, r?),
    Pow,
};

pub Op: Op<'input> = {
    <v:r"d/d\pL+"> => Op::Diff(&v[3..]),
};

pub Pow: NodeResult<'input> = {
    <b:Func> "^" <e:Pow> => builder.pow(b?, e?),
    <o:Op> <f:Pow> => builder.op(o, f?),
    <o:Op> "^" <n:r"[0-9]+"> <f:Pow> => builder.op_n(o, n.parse().unwrap(), f?),
    Func,
};

pub Func: NodeResult<'input> = {
    <f:r"\pL+\("> <g:Expr> ")" => builder.function(&f[..f.len()-1], g?),
    Term,
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e );
        v
    },
};

pub CommaE = Comma<Expr>;
pub Tuple: NodeResult<'input> = {
    "(" <t:CommaE> ")" => {
        let mut t = t;
        match t.len() {
	    0 => Ok(builder.tuple(vec![])),
	    1 => t.pop().unwrap(),
	    _ => {
                let v: Result<Vec<_>, _> = t.into_iter().collect();
                Ok(builder.tuple(v?))
	    }
        }
    },
};

pub Term: NodeResult<'input> = {
    Num,
    Var,
    Tuple,
};

Num: NodeResult<'input> = <s:r"[0-9]+"> => builder.decimal(s);
Var: NodeResult<'input> = <s:r"\pL+"> => Ok(builder.var(s));
